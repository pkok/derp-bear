#!/usr/bin/env python
import argparse
import cPickle
import os

import parsing
import smoothing

PICKLE_SUFFIX = os.path.extsep + "pkl"
PCFG_FILE = "pcfg" + PICKLE_SUFFIX
TRAIN_TREES_FILE = "train_trees" + PICKLE_SUFFIX

cache_files = [PCFG_FILE, TRAIN_TREES_FILE]

def no_pickles():
    """Remove all pickled files, so there is no cached data."""
    for pickle_file in [locals()[t] for t in locals() if t.endswith("_FILE")]:
        os.remove(pickle_file)

def step1(train_file):
    """Returns the PCFG grammar generated by the train_file's syntax trees.

    It will first look for pickled versions of the grammar, as the computation
    can take some time.
    """
    if os.path.exists(PCFG_FILE):
        return cPickle.load(open(PCFG_FILE))

    if os.path.exists(TRAIN_TREES_FILE):
        train_trees = cPickle.load(open(TRAIN_TREES_FILE))
    else:
        print "Interpreting each training tree..."
        train_trees = list(parsing.parse_tree_file(train_file))
        cPickle.dump(train_trees, open(TRAIN_TREES_FILE, 'w'))
    print "Extracting rules from the parse trees..."
    grammar = parsing.deduce_grammar(train_trees)
    cPickle.dump(grammar, open(PCFG_FILE, 'w'))
    return grammar

def step2(grammar, tokens):
    """Computes the top production rules of a tokenized sentence.

    To do so, it computes the whole parse forest of the tokens (a list of
    strings, representing the sentence).  The forest complies to the given
    grammar.
    """
    chart = parsing.cky_parser(grammar, tokens)
    if grammar['start_symbol'] not in chart[0, len(tokens)]:
        raise RuntimeError("No start symbol found in chart")
    return chart[0, len(tokens)][grammar['start_symbol']].keys()

def main():
    """Main method, doing all steps of the project after each other.
    
    It even sets up the environment so it has the right modules installed!"""
    try:
        import pyparsing
    except ImportError:
        print "Please run the next line before running this code:"
        print "    easy_install pyparsing"
        print "If easy_install is unrecognized on your system, run first:"
        print "    python ez_setup.py"
        sys.exit(1)

    argument_parser = argparse.ArgumentParser(description="")

    argument_parser.add_argument(
        "-t", "--treebank", dest="treebank", type=file, required=True,
        help="Location of parse trees meant for training the PCFG.")
    argument_parser.add_argument(
        "-i", "--input", dest="input", type=file, required=True,
        help="Location of input sentences.")
    argument_parser.add_argument(
        "-o", "--output", dest="output", type=lambda x: file(x, 'w'),
        required=True,
        help="File which will contain the generated top productions")
    argument_parser.add_argument(
        "-s", "--smooth", dest="smoothing", type=str.lower, 
        choices=smoothing.functions.keys(),
        default="none",
        help="Smoothing model of the probabilities.")
    argument_parser.add_argument(
        "-C", "--clear", dest="clear_cache", action="store_true",
        help="Delete cached files and generate new ones.")
    args = argument_parser.parse_args()

    if args.clear_cache:
        for cache_file in cache_files:
            try:
                os.remove(cache_file)
            except:
                pass

    smoothing_fn = smoothing.functions[args.smoothing]
    pcfg = smoothing_fn(step1(args.treebank))

    print "Starting to parse. Line numbers of failed sentences are printed."

    top_productions = []
    for i, line in enumerate(args.input):
        try:
            top_productions.append(step2(pcfg, line.split()))
        except RuntimeError as e:
            top_productions.append("")
            print i, ":("
    args.output.writelines(str(top_productions))
    return top_productions


if __name__ == "__main__":
    main()
